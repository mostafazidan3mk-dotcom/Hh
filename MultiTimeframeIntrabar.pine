//@version=5
indicator("Multi-Timeframe Intrabar", overlay=true, max_lines_count=500, max_labels_count=500, max_bars_back = 5000)

// Explicitly set max_bars_back for key variables
max_bars_back(time, 5000)
max_bars_back(high, 5000)
max_bars_back(low, 5000)
max_bars_back(close, 5000)
max_bars_back(open, 5000)

// Inputs
var g_TF = "Timeframes"
use_tf1         = input.bool(true, "30 Minutes", inline = "TF1", group = g_TF)
tf1             = input.timeframe("30", "", inline = "TF1", group = g_TF)
tf1_color       = input.color(color.new(#FF1493, 70), "", inline = "TF1", group = g_TF)
use_tf1_mid     = input.bool(true, "50% Level", inline = "TF1M", group = g_TF)
tf1_mid_color   = input.color(color.new(#FF1493, 50), "", inline = "TF1M", group = g_TF)

use_tf2         = input.bool(true, "1 Hour", inline = "TF2", group = g_TF)
tf2             = input.timeframe("60", "", inline = "TF2", group = g_TF)
tf2_color       = input.color(color.new(#FF4500, 70), "", inline = "TF2", group = g_TF)
use_tf2_mid     = input.bool(true, "50% Level", inline = "TF2M", group = g_TF)
tf2_mid_color   = input.color(color.new(#FF4500, 50), "", inline = "TF2M", group = g_TF)

use_tf3         = input.bool(true, "2 Hours", inline = "TF3", group = g_TF)
tf3             = input.timeframe("120", "", inline = "TF3", group = g_TF)
tf3_color       = input.color(color.new(#32CD32, 70), "", inline = "TF3", group = g_TF)
use_tf3_mid     = input.bool(true, "50% Level", inline = "TF3M", group = g_TF)
tf3_mid_color   = input.color(color.new(#32CD32, 50), "", inline = "TF3M", group = g_TF)

use_tf4         = input.bool(true, "4 Hours", inline = "TF4", group = g_TF)
tf4             = input.timeframe("240", "", inline = "TF4", group = g_TF)
tf4_color       = input.color(color.new(#1E90FF, 70), "", inline = "TF4", group = g_TF)
use_tf4_mid     = input.bool(true, "50% Level", inline = "TF4M", group = g_TF)
tf4_mid_color   = input.color(color.new(#1E90FF, 50), "", inline = "TF4M", group = g_TF)

use_tf5         = input.bool(true, "Daily", inline = "TF5", group = g_TF)
tf5             = input.timeframe("D", "", inline = "TF5", group = g_TF)
tf5_color       = input.color(color.new(#9932CC, 70), "", inline = "TF5", group = g_TF)
use_tf5_mid     = input.bool(true, "50% Level", inline = "TF5M", group = g_TF)
tf5_mid_color   = input.color(color.new(#9932CC, 50), "", inline = "TF5M", group = g_TF)

use_tf6         = input.bool(true, "Weekly", inline = "TF6", group = g_TF)
tf6             = input.timeframe("W", "", inline = "TF6", group = g_TF)
tf6_color       = input.color(color.new(#FFD700, 70), "", inline = "TF6", group = g_TF)
use_tf6_mid     = input.bool(true, "50% Level", inline = "TF6M", group = g_TF)
tf6_mid_color   = input.color(color.new(#FFD700, 50), "", inline = "TF6M", group = g_TF)

use_tf7         = input.bool(true, "Monthly", inline = "TF7", group = g_TF)
tf7             = input.timeframe("M", "", inline = "TF7", group = g_TF)
tf7_color       = input.color(color.new(#FF69B4, 70), "", inline = "TF7", group = g_TF)
use_tf7_mid     = input.bool(true, "50% Level", inline = "TF7M", group = g_TF)
tf7_mid_color   = input.color(color.new(#FF69B4, 50), "", inline = "TF7M", group = g_TF)

var g_ALERT = "Alert Options"
alert_on_m30   = input.bool(false, "Alert on M30 touch", group = g_ALERT)
alert_on_h1    = input.bool(false, "Alert on H1 touch", group = g_ALERT)
alert_on_h2    = input.bool(false, "Alert on H2 touch", group = g_ALERT)
alert_on_h4    = input.bool(false, "Alert on H4 touch", group = g_ALERT)
alert_on_daily = input.bool(false, "Alert on Daily touch", group = g_ALERT)
alert_on_weekly = input.bool(false, "Alert on Weekly touch", group = g_ALERT)
alert_on_monthly = input.bool(false, "Alert on Monthly touch", group = g_ALERT)

var g_OPT = "Options"
minbars         = input.int(1, "Minimum Bars", group = g_OPT)
maxbars         = input.int(250, "Maximum Bars", group = g_OPT)
hllinewidth     = input.int(2, "High/Low Line Width", group = g_OPT)
midlinewidth    = input.int(1, "Mid Line Width", group = g_OPT)
////

var g_LABEL = "Label Options"
// ... (your existing label options) ...
bullishLabelStyle = input.string("Label Up", "Bullish Label Style", options=[  "None", "Label Up", "Label Down", "Label Left", "Label Right", "Label Center",   "Triangle Up", "Triangle Down", "Triangle Left", "Triangle Right",   "Flag", "Circle", "Square", "Diamond", "Cross", "X-Cross", "Arrow Up", "Arrow Down" ], group=g_LABEL)
bearishLabelStyle = input.string("Label Down", "Bearish Label Style", options=[ "None", "Label Up", "Label Down", "Label Left", "Label Right", "Label Center", "Triangle Up", "Triangle Down", "Triangle Left", "Triangle Right", "Flag", "Circle", "Square", "Diamond",  "Cross", "X-Cross", "Arrow Up", "Arrow Down"  ], group=g_LABEL)
labelSize = input.string("Small", "Label Size", options=["Auto", "Tiny", "Small", "Normal", "Large", "Huge"], group=g_LABEL)

bullishBgColor = input.color(color.new(color.green, 50), "Bullish Background Color", group=g_LABEL)
bullishTextColor = input.color(color.green, "Bullish Text Color", group=g_LABEL)
bearishBgColor = input.color(color.new(color.red, 50), "Bearish Background Color", group=g_LABEL)
bearishTextColor = input.color(color.red, "Bearish Text Color", group=g_LABEL)

show_m30_labels = input.bool(true, "Show M30 Labels", group = g_LABEL)
show_h1_labels  = input.bool(true, "Show H1 Labels", group = g_LABEL)
show_h2_labels  = input.bool(true, "Show H2 Labels", group = g_LABEL)
show_h4_labels  = input.bool(true, "Show H4 Labels", group = g_LABEL)
show_daily_labels = input.bool(true, "Show Daily Labels", group = g_LABEL)
show_weekly_labels = input.bool(true, "Show Weekly Labels", group = g_LABEL)
show_monthly_labels = input.bool(true, "Show Monthly Labels", group = g_LABEL)
max_labels      = input.int(50, "Maximum number of labels to show", minval=1, maxval=500, group = g_LABEL)
show_eol_labels = input.bool(true, "Show End-of-Line Labels", group = g_LABEL)
eol_label_offset = input.int(5, "End-of-Line Label Offset", minval=1, maxval=50, group = g_LABEL)

var g_TOUCH = "Touch Options"
use_wick_touch = input.bool(true, "Use Wick Touch", group=g_TOUCH)
use_body_touch = input.bool(true, "Use Body Touch", group=g_TOUCH)

// =============================================
// Closed-HTF sweep/range detector usable via request.security
// Returns: [rangeHigh, rangeLow, prevLow, prevClose, sweptPrev, sweptRange, crossed, sweepLevel]
// - Uses ONLY closed HTF candles by referencing [1] as current closed, [2] as previous closed
// - crossed is true only on the LTF bar when the HTF candle closes
checkHTF(minBars, maxBars) =>
    int cur = 1
    int prev = 2

    float hi = high[cur]
    float lo = low[cur]
    int spanLen = 1
    for i = cur + 1 to maxBars
        float bodyUp = math.max(open[i], close[i])
        float bodyDn = math.min(open[i], close[i])
        if bodyUp <= hi and bodyDn >= lo
            hi := math.max(hi, high[i])
            lo := math.min(lo, low[i])
            spanLen += 1
        else
            break

    bool inConsolidation = spanLen >= minBars

    float prevLow   = low[prev]
    float prevClose = close[prev]

    bool sweptPrevClosed  = (low[cur] < prevLow) and (close[cur] > prevClose)

    float rangeLowUsed = inConsolidation ? lo : prevLow
    bool sweptRangeClosed = (low[cur] < rangeLowUsed) and (close[cur] > prevClose)

    // Pulse crossed only on the LTF bar that brings in the newly closed HTF bar
    bool crossed = ta.change(time) and (sweptPrevClosed or sweptRangeClosed)

    float sweepLevel = sweptPrevClosed ? prevLow : (sweptRangeClosed ? rangeLowUsed : na)

    [hi, lo, prevLow, prevClose, sweptPrevClosed, sweptRangeClosed, crossed, sweepLevel]

// =============================================
// Modified process_tf function
process_tf(tf) =>
    var float rangeHigh = na
    var float rangeLow = na
    var float rangeMid = na
    var int rangeStart = 0
    var bool inConsolidation = true
    var bool bullishTouch = false
    var bool bearishTouch = false
    
    [tfOpen, tfHigh, tfLow, tfClose, tfTime] = request.security(syminfo.tickerid, tf, [open, high, low, close, time], barmerge.gaps_off, barmerge.lookahead_on)
    
    newBar = ta.change(tfTime) != 0
    
    tfUp = tfHigh
    tfDown = tfLow
    tfChildUp = tfOpen > tfClose ? tfOpen : tfClose
    tfChildDown = tfOpen > tfClose ? tfClose : tfOpen
    
    if newBar
        upControl = tfChildUp > rangeHigh and bar_index - rangeStart > minbars and bar_index - rangeStart <= maxbars
        downControl = tfChildDown < rangeLow and bar_index - rangeStart > minbars and bar_index - rangeStart <= maxbars
        
        if (upControl or downControl)
            inConsolidation := false
        
        if (inConsolidation and tfChildDown <= rangeHigh and tfChildDown >= rangeLow and tfChildUp <= rangeHigh and tfChildUp >= rangeLow and bar_index > 1)
            rangeStart := rangeStart
        else
            rangeHigh := tfHigh
            rangeLow := tfLow
            rangeStart := bar_index
            inConsolidation := true
        
        if not inConsolidation and (bar_index - rangeStart > maxbars or bar_index - rangeStart < minbars)
            inConsolidation := true
        
        rangeMid := (rangeHigh + rangeLow) / 2
        bullishTouch := false
        bearishTouch := false
    
    if inConsolidation
        bullishWickTouch = low < rangeLow and close > rangeLow and high < rangeHigh
        bullishBodyTouch = open < rangeLow and close > rangeLow
        bearishWickTouch = high > rangeHigh and close < rangeHigh and low > rangeLow
        bearishBodyTouch = open > rangeHigh and close < rangeHigh
        
        bullishTouch := (use_wick_touch and bullishWickTouch) or (use_body_touch and bullishBodyTouch)
        bearishTouch := (use_wick_touch and bearishWickTouch) or (use_body_touch and bearishBodyTouch)
    
    [rangeHigh, rangeLow, rangeMid, rangeStart, inConsolidation, newBar, bullishTouch, bearishTouch]

// Process data for each timeframe
[high1, low1, mid1, start1, inRange1, newBar1, bullishTouch1, bearishTouch1] = process_tf(tf1)
[high2, low2, mid2, start2, inRange2, newBar2, bullishTouch2, bearishTouch2] = process_tf(tf2)
[high3, low3, mid3, start3, inRange3, newBar3, bullishTouch3, bearishTouch3] = process_tf(tf3)
[high4, low4, mid4, start4, inRange4, newBar4, bullishTouch4, bearishTouch4] = process_tf(tf4)
[high5, low5, mid5, start5, inRange5, newBar5, bullishTouch5, bearishTouch5] = process_tf(tf5)
[high6, low6, mid6, start6, inRange6, newBar6, bullishTouch6, bearishTouch6] = process_tf(tf6)
[high7, low7, mid7, start7, inRange7, newBar7, bullishTouch7, bearishTouch7] = process_tf(tf7)

// Closed-HTF sweep detection for each timeframe (via request.security)
[crH1, crL1, prevL1, prevC1, swPrev1, swRange1, crossed1, swLvl1] = request.security(syminfo.tickerid, tf1, checkHTF(minbars, maxbars), barmerge.gaps_off, barmerge.lookahead_off)
[crH2, crL2, prevL2, prevC2, swPrev2, swRange2, crossed2, swLvl2] = request.security(syminfo.tickerid, tf2, checkHTF(minbars, maxbars), barmerge.gaps_off, barmerge.lookahead_off)
[crH3, crL3, prevL3, prevC3, swPrev3, swRange3, crossed3, swLvl3] = request.security(syminfo.tickerid, tf3, checkHTF(minbars, maxbars), barmerge.gaps_off, barmerge.lookahead_off)
[crH4, crL4, prevL4, prevC4, swPrev4, swRange4, crossed4, swLvl4] = request.security(syminfo.tickerid, tf4, checkHTF(minbars, maxbars), barmerge.gaps_off, barmerge.lookahead_off)
[crH5, crL5, prevL5, prevC5, swPrev5, swRange5, crossed5, swLvl5] = request.security(syminfo.tickerid, tf5, checkHTF(minbars, maxbars), barmerge.gaps_off, barmerge.lookahead_off)
[crH6, crL6, prevL6, prevC6, swPrev6, swRange6, crossed6, swLvl6] = request.security(syminfo.tickerid, tf6, checkHTF(minbars, maxbars), barmerge.gaps_off, barmerge.lookahead_off)
[crH7, crL7, prevL7, prevC7, swPrev7, swRange7, crossed7, swLvl7] = request.security(syminfo.tickerid, tf7, checkHTF(minbars, maxbars), barmerge.gaps_off, barmerge.lookahead_off)

// ---------------------------------------------
// Lower-timeframe (intrabar) sweep detection against HTF reference lows
// - Uses prevL (previous HTF low) and crL (consolidation low) as static reference during the HTF bar
// - Pulses once per HTF bar when a valid LTF sweep+reclaim occurs; resets on new HTF bar
var bool crossedLtf1 = false
var bool crossedLtf2 = false
var bool crossedLtf3 = false
var bool crossedLtf4 = false
var bool crossedLtf5 = false
var bool crossedLtf6 = false
var bool crossedLtf7 = false

// Reset latches on new HTF bars
if newBar1
    crossedLtf1 := false
if newBar2
    crossedLtf2 := false
if newBar3
    crossedLtf3 := false
if newBar4
    crossedLtf4 := false
if newBar5
    crossedLtf5 := false
if newBar6
    crossedLtf6 := false
if newBar7
    crossedLtf7 := false

// Helper to build wick/body reclaim conditions
reclaimWick(level) => low < level and close > level
reclaimBody(level) => open < level and close > level

// M30
bullPrev1 = (use_wick_touch and reclaimWick(prevL1)) or (use_body_touch and reclaimBody(prevL1))
bullCon1  = (use_wick_touch and reclaimWick(crL1))   or (use_body_touch and reclaimBody(crL1))
pulseLtf1 = (bullPrev1 or bullCon1) and not crossedLtf1
if pulseLtf1
    crossedLtf1 := true

// H1
bullPrev2 = (use_wick_touch and reclaimWick(prevL2)) or (use_body_touch and reclaimBody(prevL2))
bullCon2  = (use_wick_touch and reclaimWick(crL2))   or (use_body_touch and reclaimBody(crL2))
pulseLtf2 = (bullPrev2 or bullCon2) and not crossedLtf2
if pulseLtf2
    crossedLtf2 := true

// H2
bullPrev3 = (use_wick_touch and reclaimWick(prevL3)) or (use_body_touch and reclaimBody(prevL3))
bullCon3  = (use_wick_touch and reclaimWick(crL3))   or (use_body_touch and reclaimBody(crL3))
pulseLtf3 = (bullPrev3 or bullCon3) and not crossedLtf3
if pulseLtf3
    crossedLtf3 := true

// H4
bullPrev4 = (use_wick_touch and reclaimWick(prevL4)) or (use_body_touch and reclaimBody(prevL4))
bullCon4  = (use_wick_touch and reclaimWick(crL4))   or (use_body_touch and reclaimBody(crL4))
pulseLtf4 = (bullPrev4 or bullCon4) and not crossedLtf4
if pulseLtf4
    crossedLtf4 := true

// D
bullPrev5 = (use_wick_touch and reclaimWick(prevL5)) or (use_body_touch and reclaimBody(prevL5))
bullCon5  = (use_wick_touch and reclaimWick(crL5))   or (use_body_touch and reclaimBody(crL5))
pulseLtf5 = (bullPrev5 or bullCon5) and not crossedLtf5
if pulseLtf5
    crossedLtf5 := true

// W
bullPrev6 = (use_wick_touch and reclaimWick(prevL6)) or (use_body_touch and reclaimBody(prevL6))
bullCon6  = (use_wick_touch and reclaimWick(crL6))   or (use_body_touch and reclaimBody(crL6))
pulseLtf6 = (bullPrev6 or bullCon6) and not crossedLtf6
if pulseLtf6
    crossedLtf6 := true

// M
bullPrev7 = (use_wick_touch and reclaimWick(prevL7)) or (use_body_touch and reclaimBody(prevL7))
bullCon7  = (use_wick_touch and reclaimWick(crL7))   or (use_body_touch and reclaimBody(crL7))
pulseLtf7 = (bullPrev7 or bullCon7) and not crossedLtf7
if pulseLtf7
    crossedLtf7 := true

// Optional LTF sweep labels (use existing label manager and per-TF visibility switches)
if use_tf1 and show_m30_labels and pulseLtf1
    manageLabelCount("LTF-SW-M30", bullPrev1 ? prevL1 : crL1, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))
if use_tf2 and show_h1_labels and pulseLtf2
    manageLabelCount("LTF-SW-H1", bullPrev2 ? prevL2 : crL2, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))
if use_tf3 and show_h2_labels and pulseLtf3
    manageLabelCount("LTF-SW-H2", bullPrev3 ? prevL3 : crL3, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))
if use_tf4 and show_h4_labels and pulseLtf4
    manageLabelCount("LTF-SW-H4", bullPrev4 ? prevL4 : crL4, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))
if use_tf5 and show_daily_labels and pulseLtf5
    manageLabelCount("LTF-SW-D", bullPrev5 ? prevL5 : crL5, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))
if use_tf6 and show_weekly_labels and pulseLtf6
    manageLabelCount("LTF-SW-W", bullPrev6 ? prevL6 : crL6, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))
if use_tf7 and show_monthly_labels and pulseLtf7
    manageLabelCount("LTF-SW-M", bullPrev7 ? prevL7 : crL7, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))

// Modified plot_lines function
plot_lines(tfColor, midColor, high, low, mid, start, inRange, newBar, useMid, bullishTouch, bearishTouch, tfName) =>
    var line highLine = na
    var line lowLine = na
    var line midLine = na
    var label highLabel = na
    var label lowLabel = na
    
    if newBar and inRange
        if not na(highLine)
            line.delete(highLine)
            line.delete(lowLine)
            line.delete(midLine)
        if not na(highLabel)
            label.delete(highLabel)
            label.delete(lowLabel)
        
        validStart = math.max(start, 0)
        highLine := line.new(validStart, high, bar_index, high, color=tfColor, width=hllinewidth)
        lowLine := line.new(validStart, low, bar_index, low, color=tfColor, width=hllinewidth)
        if useMid
            midLine := line.new(validStart, mid, bar_index, mid, color=midColor, width=midlinewidth, style=line.style_dashed)
        
        if show_eol_labels
            highLabel := label.new(bar_index + eol_label_offset, high, text=tfName + " CRT High", color=color.new(tfColor, 70), textcolor=tfColor, style=label.style_none, size=size.small)
            lowLabel := label.new(bar_index + eol_label_offset, low, text=tfName + " CRT Low", color=color.new(tfColor, 70), textcolor=tfColor, style=label.style_none, size=size.small)
    
    if not na(highLine) and inRange
        line.set_x2(highLine, bar_index)
        line.set_x2(lowLine, bar_index)
        if useMid and not na(midLine)
            line.set_x2(midLine, bar_index)
        
        if show_eol_labels
            label.set_x(highLabel, bar_index + eol_label_offset)
            label.set_y(highLabel, high)
            label.set_x(lowLabel, bar_index + eol_label_offset)
            label.set_y(lowLabel, low)
    
    [bullishTouch, bearishTouch]

// Plot lines for each timeframe
if use_tf1
    [bullishTouch1, bearishTouch1] = plot_lines(tf1_color, tf1_mid_color, high1, low1, mid1, start1, inRange1, newBar1, use_tf1_mid, bullishTouch1, bearishTouch1, "M30")
if use_tf2
    [bullishTouch2, bearishTouch2] = plot_lines(tf2_color, tf2_mid_color, high2, low2, mid2, start2, inRange2, newBar2, use_tf2_mid, bullishTouch2, bearishTouch2, "H1")
if use_tf3
    [bullishTouch3, bearishTouch3] = plot_lines(tf3_color, tf3_mid_color, high3, low3, mid3, start3, inRange3, newBar3, use_tf3_mid, bullishTouch3, bearishTouch3, "H2")
if use_tf4
    [bullishTouch4, bearishTouch4] = plot_lines(tf4_color, tf4_mid_color, high4, low4, mid4, start4, inRange4, newBar4, use_tf4_mid, bullishTouch4, bearishTouch4, "H4")
if use_tf5
    [bullishTouch5, bearishTouch5] = plot_lines(tf5_color, tf5_mid_color, high5, low5, mid5, start5, inRange5, newBar5, use_tf5_mid, bullishTouch5, bearishTouch5, "D")
if use_tf6
    [bullishTouch6, bearishTouch6] = plot_lines(tf6_color, tf6_mid_color, high6, low6, mid6, start6, inRange6, newBar6, use_tf6_mid, bullishTouch6, bearishTouch6, "W")
if use_tf7
    [bullishTouch7, bearishTouch7] = plot_lines(tf7_color, tf7_mid_color, high7, low7, mid7, start7, inRange7, newBar7, use_tf7_mid, bullishTouch7, bearishTouch7, "M")

// Optimized label management
// Function to convert string input to label style
// Function to convert string input to label style
// Update the function to convert string input to label style
getLabelStyle(styleString) =>
    switch styleString
        "None" => label.style_none
        "Label Up" => label.style_label_up
        "Label Down" => label.style_label_down
        "Label Left" => label.style_label_left
        "Label Right" => label.style_label_right
        "Label Center" => label.style_label_center
        "Triangle Up" => label.style_triangleup
        "Triangle Down" => label.style_triangledown
     
        "Flag" => label.style_flag
        "Circle" => label.style_circle
        "Square" => label.style_square
        "Diamond" => label.style_diamond
        "Cross" => label.style_cross
        "X-Cross" => label.style_xcross
        "Arrow Up" => label.style_arrowup
        "Arrow Down" => label.style_arrowdown
        => label.style_label_up  // default

// Update the function to convert string input to size
getLabelSize(sizeString) =>
    switch sizeString
        "Auto" => size.auto
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        "Huge" => size.huge
        => size.auto  // default

// Optimized label management
var label[] labels = array.new_label()

manageLabelCount(labelText, y, bgColor, textColor, style, size) =>
    if array.size(labels) >= max_labels
        label.delete(array.shift(labels))
    newLabel = label.new(bar_index, y, labelText, color=bgColor, textcolor=textColor, style=style, size=size)
    array.push(labels, newLabel)

// Function to check and create labels for a timeframe
checkAndCreateLabel(show, bullishTouch, bearishTouch, tfText) =>
    if show and bullishTouch
        manageLabelCount("BT-" + tfText, low, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))
    if show and bearishTouch
        manageLabelCount("BT-" + tfText, high, bearishBgColor, bearishTextColor, getLabelStyle(bearishLabelStyle), getLabelSize(labelSize))

// Sweep label creator (uses bullish style/colors as we detect low sweeps + reclaim)
checkAndCreateSweepLabel(show, crossed, sweptPrev, sweptRange, tfText, sweepLevel) =>
    if show and crossed and (sweptPrev or sweptRange) and not na(sweepLevel)
        manageLabelCount("SW-" + tfText, sweepLevel, bullishBgColor, bullishTextColor, getLabelStyle(bullishLabelStyle), getLabelSize(labelSize))

// Apply labels for each timeframe (touches)
checkAndCreateLabel(show_m30_labels, bullishTouch1, bearishTouch1, "M30")
checkAndCreateLabel(show_h1_labels, bullishTouch2, bearishTouch2, "H1")
checkAndCreateLabel(show_h2_labels, bullishTouch3, bearishTouch3, "H2")
checkAndCreateLabel(show_h4_labels, bullishTouch4, bearishTouch4, "H4")
checkAndCreateLabel(show_daily_labels, bullishTouch5, bearishTouch5, "D")
checkAndCreateLabel(show_weekly_labels, bullishTouch6, bearishTouch6, "W")
checkAndCreateLabel(show_monthly_labels, bullishTouch7, bearishTouch7, "M")

// Apply sweep labels for each timeframe (closed-HTF sweeps)
if use_tf1
    checkAndCreateSweepLabel(show_m30_labels, crossed1, swPrev1, swRange1, "M30", swLvl1)
if use_tf2
    checkAndCreateSweepLabel(show_h1_labels, crossed2, swPrev2, swRange2, "H1", swLvl2)
if use_tf3
    checkAndCreateSweepLabel(show_h2_labels, crossed3, swPrev3, swRange3, "H2", swLvl3)
if use_tf4
    checkAndCreateSweepLabel(show_h4_labels, crossed4, swPrev4, swRange4, "H4", swLvl4)
if use_tf5
    checkAndCreateSweepLabel(show_daily_labels, crossed5, swPrev5, swRange5, "D", swLvl5)
if use_tf6
    checkAndCreateSweepLabel(show_weekly_labels, crossed6, swPrev6, swRange6, "W", swLvl6)
if use_tf7
    checkAndCreateSweepLabel(show_monthly_labels, crossed7, swPrev7, swRange7, "M", swLvl7)

// Alert conditions (existing touch alerts)
if alert_on_m30 and (bullishTouch1 or bearishTouch1)
    alert("M30 touch detected", alert.freq_once_per_bar_close)

if alert_on_h1 and (bullishTouch2 or bearishTouch2)
    alert("H1 touch detected", alert.freq_once_per_bar_close)

if alert_on_h2 and (bullishTouch3 or bearishTouch3)
    alert("H2 touch detected", alert.freq_once_per_bar_close)

if alert_on_h4 and (bullishTouch4 or bearishTouch4)
    alert("H4 touch detected", alert.freq_once_per_bar_close)

if alert_on_daily and (bullishTouch5 or bearishTouch5)
    alert("Daily touch detected", alert.freq_once_per_bar_close)

if alert_on_weekly and (bullishTouch6 or bearishTouch6)
    alert("Weekly touch detected", alert.freq_once_per_bar_close)

if alert_on_monthly and (bullishTouch7 or bearishTouch7)
    alert("Monthly touch detected", alert.freq_once_per_bar_close)